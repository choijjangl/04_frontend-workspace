<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area {
            border: 1px solid red;
        }

        .small {
            height: 100px;
        }

        .big {
            height: 200px;
        }
    </style>
</head>

<body>
    <h1>배열</h1>
    <p>
        변수 선언시 별도의 자료형 지정이 없기 때문에 <br>
        어떤 자료형의 값들이든 다 하나의 배열 공간에 담을 수 있음, *크기의 제약도 없다.(자바의 배열보단 컬렉션과 유사)<br>
        <button onclick="arraytest1();">확인하기</button>
    <div id="area1" class="area small"></div>
    </p>
    <script>
        function arraytest1() {
            const arr = ["문동은", '서울', 20, true, [1, 2, 3]]; // 배열 객체 (type == Object)

            console.log(arr);
            console.log(arr[2]);
            console.log(arr[4]);
            console.log(arr[4][2]);

            const area1 = document.getElementById("area1");

            // for(let i = 0 ; i < arr.length;i++){    // const로 사용하면 고정됨.
            //     area1.innerHTML += arr[i] + "<br>"
            // }

            // 배열의 0번 인덱스부터 마지막 인덱스까지
            // 순차적으로 모든 요소에 접글할 목적이라고 한다면
            // for in문활용가능

            // for(let 변수 in 순차적으로 접근할 배열){}
            for (let i in arr) {
                area1.innerHTML += arr[i] + "<br>";
            }
        }
    </script>

    <hr>

    <h3>* 배열의 선언</h3>

    <button onclick="arrayTest2();">확인하기</button>

    <br><br>

    <script>
        function arrayTest2() {
            // 배열 선언
            const arr1 = new Array(); // 빈 배열 하나 만들어짐
            const arr2 = new Array(3); // 크기 3인 빈 배열
            const arr3 = [];

            // console.log(arr1);
            // console.log(arr2);
            // console.log(arr3);

            //배열에 값 대입
            arr1[0] = "네이마르";
            arr1[1] = "에브라";
            arr1[9] = "청포도";
            console.log(arr1);

            arr2[0] = "손흥민";
            arr2[1] = "박지성";
            arr2[2] = "안정환";
            arr2[3] = "이강인";

            console.log(arr2);

            // 배열 선언과 동시에 초기화
            const arr4 = new Array("손석희", "문준철", "장대붕");
            const arr5 = ["자바", "자스", "씨에스에스"];

            console.log(arr4);
            console.log(arr5);
        }
    </script>

    <hr>

    <h3>* 배열관련 메소드</h3>

    <h4>1) indexOf(찾고자 하는 요소) : 배열에서 해당요소가 위치해있는 인덱스 반환</h4>

    <div id="area2" class="area small"></div>
    <button onclick="indexOfTest();">Check</button>

    <script>
        function indexOfTest() {
            const area2 = document.getElementById("area2");

            const arr = ["사장", "부장", "대리", "사원", "인턴"];

            const job = prompt("찾고자 하는 직급  명 입력");

            const index = arr.indexOf(job); // 해당 요소를 찾지 못하면 -1 반환
            console.log(index);

            // 당신이 찾는 직급 xx은(는) x번째 인덱스에 있습니다.
            // 당신이 찾는 직급 xx은(는) 없는 직급입니다.

            area2.innerHTML = "당신이 찾는 직급 : " + job + "은[는]"
            if (index == -1) {
                area2.innerHTML += "없는 직급입니다.";
            } else {
                area2.innerHTML += index + "번째에 있습니다."
            }

            // 자바 스크립트에서 두 값이 동일한지 비교하는 연산자

            console.log(1 == 1);    // true
            console.log(1 == "1");  // true => 동등연산자(자료형과 무관하게 실제값만 일치해도 true)
            console.log(1 === "1"); // false => 일치연산자(값, 자료형 둘다 일치해야 true)
        }
    </script>

    <hr>

    <h4>2) 배열.concat(배열 , 배열) : 배열에대가 여러개의 배열을 결합하고자 할 때 사용</h4>

    <div id="area3" class="area big"></div>
    <button onclick="concatTest();">확인하기</button>

    <script>
        function concatTest() {
            const area3 = document.getElementById("area3");

            const arr1 = ["만두", "순대"];
            const arr2 = ["아이유", "박보검", "박보영"];

            area3.innerHTML += "arr1 : " + arr1 + "<br>";
            area3.innerHTML += "arr2 : " + arr2 + "<br>";

            area3.innerHTML += "arr1 기준으로 배열 합침 : " + arr1.concat(arr2) + "<br>";
            area3.innerHTML += "다시 arr1 : " + arr1 + "<br>";
            // concat는 원본 배열에 영향을 주지 않는 메소드
            // 두개의 배열을 합쳐서 새로운 배열로 반환

            area3.innerHTML += "arr2 기준으로 배열 합침 : " + arr2.concat(arr1, [1, 2, 3]) + "<br>";
        }
    </script>



    <hr>

    <h4>3) 배열.reverse() : 배열에 담긴 값들을 역순으로 바꿔주는 메소드</h4>
    <div id="area4" class="area small"></div>
    <button onclick="reverseTest();">확인하기</button>

    <script>
        function reverseTest() {
            const area4 = document.getElementById("area4");

            let arr = ["참깨빵", "순쇠고기 패티2장", "특별한소스", "양상추"];

            area4.innerHTML += "arr : " + arr + "<br>";
            area4.innerHTML += "reverse : " + arr.reverse() + "<br>";
            area4.innerHTML += "arr : " + arr + "<br>";
            // reverse는 원본 배열에 영향을 주는 메소드
            // 지정된 배열을 거꾸로 바꾸는 메소드

        }
    </script>

    <hr>

    <h4>4) 배열.sort() : 배열안에 담긴 값들 오름차순 정렬시켜주는 메소드</h4>

    <div id="area5" class="area big"></div>
    <button onclick="sortTest();">확인쓰</button>

    <script>
        function sortTest() {
            let area5 = document.getElementById("area5");

            let arr1 = ["최민수", "강민수", "조민수", "김민수", "하민수", "제갈민수", "육민수"]
            let arr2 = [2, 1, 5, 3, 4, 6, 9, 8, 7];
            let arr3 = [3, 2, 5, 4, 1];

            area5.innerHTML += "arr1 : " + arr1 + "<br>";
            area5.innerHTML += "arr2 : " + arr2 + "<br>";

            area5.innerHTML += "sort 1 결과 : " + arr1.sort() + "<br>";
            area5.innerHTML += "sort 2 결과 : " + arr2.sort() + "<br>";

            area5.innerHTML += "arr1 : " + arr1 + "<br>";
            area5.innerHTML += "arr2 : " + arr2 + "<br>";
            // sort는 원본 배열에 영향을 주는 메소드
            // 지정된 배열을 오름차순으로 정열

            // 내림차순으로 하고 싶다면 sort로 정렬 후, reverse로 뒤집으면 됨.

            area5.innerHTML += "arr3 : " + arr3 + "<br>";
            area5.innerHTML += "arr3 sort : " + arr3.sort() + "<br>";
            area5.innerHTML += "arr3 reverse : " + arr3.reverse() + "<br>";

            area5.innerHTML += "arr3 바뀐 값 : " + arr3 + "<br>";
        }
    </script>

    <hr>

    <h4>
        5_1) 배열.push(추가할요소) : 배열의 맨 뒤에 요소 추가시키고 배열의 크기 반환
        5_2) 배열.pop() : 배열의 맨 뒤 요소 제거시키고 제거된 요소 반환.
    </h4>

    <div id="area6" class="area big"></div>
    <button onclick="pushPopTest();">확인des</button>

    <script>
        function pushPopTest() {
            let area6 = document.querySelector("#area6");

            let arr = ["서초동", "방배동", "역삼동", "개포동", "일원동"];

            area6.innerHTML += "arr : " + arr + "<br>";
            area6.innerHTML += "arr에 push 후 : " + arr.push("신도림동") + "<br>";
            area6.innerHTML += "다시 arr : " + arr + "<br>";
            // push는 원본 배열에 영향을 주는 메소드

            arr.push("잠실본동");
            area6.innerHTML += "arr에 push 후 : " + arr + "<br>";

            area6.innerHTML += "arr에 pop 후 : " + arr.pop() + "<br>"
            area6.innerHTML += "다시 arr : " + arr + "<br>";
            // pop은 원본 배열에 영향을 주는 메소드

            arr.pop();
            arr.pop();
            arr.pop();

            area6.innerHTML += "최종 arr : " + arr + "<br>";
            // 서초동, 방배동, 역삼동이 최종으로 남음
            // 맨뒤에 값을 제거
        }
    </script>


    <hr>

    <br> <br>
    <h4>
        6_1 배열.unshift(추가할요소) : 배열의 맨 앞에 요소 추가 후 배열의 크기 반환 <br>
        6_2 배열.shift() : 배열의 맨 앞에 요소 제거 시키고 제거도니 요소 반환
    </h4>
    <div id="area7" class="area big"></div>
    <button onclick="shiftUnshiftTest();">확인</button>

    <script>
        function shiftUnshiftTest() {
            let area7 = document.querySelector("#area7");

            const arr = ["펜싱", "주짓수", "유도", "볼링", "태권도"];

            area7.innerHTML += "arr : " + arr + "<br>";

            arr.unshift("농구")
            area7.innerHTML += "arr unshift 후 : " + arr + "<br>";
            area7.innerHTML += "arr unshift 후 배열의 크기 : " + arr.unshift("탁구") + "<br>"

            area7.innerHTML += "arr에 shift 후 : " + arr.shift() + "<br>";
            area7.innerHTML += "최종 arr : " + arr + "<br>";
            // 둘다 원본 배열에 영향을 주는 메소드
        }
    </script>

    <h4>
        7_1) 배열.slice(시작인덱스, 끝인덱스) : 배열로부터 시작인덱스에서 끝 인덱스까지 단지 추출해주는 메소드
        7_2) 배열.splice(시작인데스, 제거개수[, 추가할 값])
    </h4>

    <div id="area8" class="area small"></div>
    <button onclick="sliceSpliceTest();">확인</button>

    <script>
        function sliceSpliceTest() {
            const area8 = document.getElementById("area8");

            const arr = ["Java", "Oracle", "HTML", "CSS", "JavaScript"];

            area8.innerHTML += "arr : " + arr + "<br>";

            // slice (시작, 끝)
            area8.innerHTML += "arr : " + arr.slice(2, 4) + "<br>";
            area8.innerHTML += "arr : " + arr + "<br>";
            // 원본 배열에 영향을 주지 않는 메소드

            // splice(시작, 제거개수[, 추가할요소])
            area8.innerHTML += "splice 결과 : " + arr.splice(2, 2, "Spring") + "<br>";
            area8.innerHTML += "arr : " + arr + "<br>";
            // 원본 배열에 영향을 주는 메소드
            // 빈자리를 Spring으로 채움

        }
    </script>
    
    <hr>

    <h4> 
        8) 배열.toString() / 배열.join([구분자]) : 배열에 각 인덱스에 담긴 값들을 하나의 "문자열"로 합쳐서 반환
    </h4>

    <div id="area9" class="area small"></div>
    <button onclick="toStringJoinTest();">확인</button>

    <script>
        function toStringJoinTest(){
            const area9 = document.querySelector("#area9");

            const arr = ["나는", "어제", "더글로리를", "봤다!!", "존잼"];

            // 원래 toString을 호출하고 있었던거. toString은 배열을 모아 콤마찍고 하나의 문자열로 출력해줌
            area9.innerHTML += "arr : " + arr/*.toString()*/ + "<br>"; 
            area9.innerHTML += "toString : " + arr.toString() + "<br>";
            // 객체를 화면에 출력하면 내부적으로 객체.toString() 호출한 결과가 출력

            area9.innerHTML += "join : " + arr.join() + "<br>";
            // join은 기본적으로는 ,로 연이어줌! => 직접 구분자 제시 가능
            area9.innerHTML += "구분자 제시한 join : " + arr.join(" ") + "<br>";
            // ,콤마대신해서 구분자가 나옴.
        }
    </script>

</body>

</html>